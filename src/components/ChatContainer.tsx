import { Send, Square, Loader2 } from 'lucide-react'
import { clsx } from 'clsx'
import { useState, useRef, useEffect } from 'react'
import type {
  ChatMessage,
  TaskItem,
  PendingQuestion,
  ApprovalRequest,
  FileChange,
  ToolCall,
  ChatTheme,
  Artifact,
} from '../types'
import { MessageBubble } from './MessageBubble'
import { ThinkingBox } from './ThinkingBox'
import { TodoBox } from './TodoBox'
import { QuestionCard } from './QuestionCard'
import { ApprovalCard } from './ApprovalCard'
import { DiffView } from './DiffView'
import { ToolCallCard } from './ToolCallCard'

/** Layout options for empty state */
export type EmptyStateLayout = 'default' | 'top-input'

export interface ChatContainerProps {
  /** List of messages to display */
  messages: ChatMessage[]
  /** Whether the assistant is currently processing */
  isProcessing?: boolean
  /** Current thinking text (while streaming) */
  thinkingText?: string
  /** Current tasks */
  tasks?: TaskItem[]
  /** Pending question from assistant */
  pendingQuestion?: PendingQuestion
  /** Pending approval request from assistant */
  pendingApproval?: ApprovalRequest
  /** File diffs generated by assistant */
  diffs?: FileChange[]
  /** Called when user sends a message */
  onSend?: (message: string) => void
  /** Called when user stops processing */
  onStop?: () => void
  /** Called when user answers a question */
  onAnswerQuestion?: (answer: string | string[]) => void
  /** Called when user responds to an approval request */
  onAnswerApproval?: (approved: boolean) => void
  /** Custom tool call renderers */
  toolRenderers?: Record<string, (toolCall: ToolCall) => React.ReactNode>
  /** Custom theme */
  theme?: ChatTheme
  /** Placeholder text for input */
  placeholder?: string
  /** Custom class name */
  className?: string
  /** Custom assistant avatar */
  assistantAvatar?: React.ReactNode
  /** Custom user avatar */
  userAvatar?: React.ReactNode
  /** Welcome message when no messages */
  welcomeMessage?: React.ReactNode
  /** Center the chat with max-width for better readability (useful when displayed full-width) */
  centered?: boolean
  /**
   * Layout for empty state (no messages)
   * - 'default': Input at bottom, welcomeMessage centered
   * - 'top-input': Input at top, welcomeMessage centered below (like ChatGPT/Claude)
   * @default 'default'
   */
  emptyStateLayout?: EmptyStateLayout
  /** Placeholder text for input when in empty state (falls back to placeholder) */
  emptyStatePlaceholder?: string
  /**
   * Show input hint text ("Enter to send · Shift+Enter for new line")
   * @default true when emptyStateLayout is 'top-input', false otherwise
   */
  showInputHint?: boolean
  /** Render custom content after each message (for approvals, diffs, artifacts, etc.) */
  renderMessageExtras?: (message: ChatMessage, isStreaming: boolean) => React.ReactNode
  /** Suggestion buttons shown in empty state - clicking sends the message */
  suggestions?: string[]
  /** Called when a message with an artifact is received */
  onArtifact?: (artifact: Artifact) => void
}

export function ChatContainer({
  messages,
  isProcessing = false,
  thinkingText,
  tasks,
  pendingQuestion,
  pendingApproval,
  diffs,
  onSend,
  onStop,
  onAnswerQuestion,
  onAnswerApproval,
  toolRenderers,
  theme,
  placeholder = 'Type a message...',
  className,
  assistantAvatar,
  userAvatar,
  welcomeMessage,
  centered = false,
  emptyStateLayout = 'default',
  emptyStatePlaceholder,
  showInputHint,
  renderMessageExtras,
  suggestions,
  onArtifact,
}: ChatContainerProps) {
  const [input, setInput] = useState('')
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const inputRef = useRef<HTMLTextAreaElement>(null)

  // Determine if we should show the hint
  const shouldShowHint = showInputHint ?? (emptyStateLayout === 'top-input' && messages.length === 0)

  // Use empty state placeholder when empty, otherwise use regular placeholder
  const currentPlaceholder = messages.length === 0 && emptyStatePlaceholder
    ? emptyStatePlaceholder
    : placeholder

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }

  useEffect(() => {
    scrollToBottom()
  }, [messages, thinkingText, pendingQuestion, pendingApproval, diffs])

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (!input.trim() || isProcessing) return

    onSend?.(input.trim())
    setInput('')
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      handleSubmit(e)
    }
  }

  // Auto-resize textarea (larger max for empty state with top-input layout)
  useEffect(() => {
    if (inputRef.current) {
      inputRef.current.style.height = 'auto'
      const isEmptyTopInput = emptyStateLayout === 'top-input' && messages.length === 0
      const maxHeight = isEmptyTopInput ? 300 : 200
      const minHeight = isEmptyTopInput ? 80 : 36
      inputRef.current.style.height = Math.max(minHeight, Math.min(inputRef.current.scrollHeight, maxHeight)) + 'px'
    }
  }, [input, messages.length, emptyStateLayout])

  // Track last seen artifact to avoid duplicate callbacks
  const lastArtifactIdRef = useRef<string | null>(null)

  // Detect new artifacts and call onArtifact
  useEffect(() => {
    if (!onArtifact) return
    const lastMessage = messages[messages.length - 1]
    if (lastMessage?.artifacts?.length) {
      const latestArtifact = lastMessage.artifacts[lastMessage.artifacts.length - 1]
      if (latestArtifact.id !== lastArtifactIdRef.current) {
        lastArtifactIdRef.current = latestArtifact.id
        onArtifact(latestArtifact)
      }
    }
  }, [messages, onArtifact])

  // Apply theme as CSS variables
  const themeStyle = theme
    ? ({
        '--chat-bg': theme.bg,
        '--chat-surface': theme.surface,
        '--chat-border': theme.border,
        '--chat-text': theme.text,
        '--chat-text-secondary': theme.textSecondary,
        '--chat-accent': theme.accent,
        '--chat-accent-hover': theme.accentHover,
        '--chat-success': theme.success,
        '--chat-warning': theme.warning,
        '--chat-error': theme.error,
      } as React.CSSProperties)
    : undefined

  const renderToolCalls = (toolCalls: ToolCall[]) => {
    return (
      <div className="space-y-2">
        {toolCalls.map((tc) =>
          toolRenderers?.[tc.name] ? (
            <div key={tc.id}>{toolRenderers[tc.name](tc)}</div>
          ) : (
            <ToolCallCard key={tc.id} toolCall={tc} />
          )
        )}
      </div>
    )
  }

  // Input component (reused in both layouts)
  const renderInput = (isTopInput = false) => {
    if (isTopInput) {
      // Top-input style: textarea with button inside a styled container
      return (
        <div className={clsx('p-4', centered && 'max-w-3xl mx-auto')}>
          <div className="bg-[var(--chat-surface)] border border-[var(--chat-border)] rounded-xl focus-within:border-[var(--chat-accent)] focus-within:ring-1 focus-within:ring-[var(--chat-accent)]/50 transition-all">
            <textarea
              ref={inputRef}
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyDown={handleKeyDown}
              placeholder={currentPlaceholder}
              disabled={isProcessing}
              rows={3}
              className={clsx(
                'w-full px-4 py-3 bg-transparent',
                'text-sm text-[var(--chat-text)] placeholder:text-[var(--chat-text-secondary)]',
                'focus:outline-none resize-none',
                'disabled:opacity-50'
              )}
            />
            <div className="px-4 pb-3 flex items-center justify-between">
              {shouldShowHint ? (
                <p className="text-xs text-[var(--chat-text-secondary)]">
                  Enter to send · Shift+Enter for new line
                </p>
              ) : (
                <div />
              )}
              <div className="flex items-center gap-2">
                {isProcessing ? (
                  <button
                    type="button"
                    onClick={onStop}
                    className={clsx(
                      'px-3 py-1.5 rounded-lg transition-colors flex items-center gap-1.5 text-xs font-medium',
                      'bg-[var(--chat-error)]/20 hover:bg-[var(--chat-error)]/30 text-[var(--chat-error)]'
                    )}
                  >
                    <Square className="w-3 h-3" />
                    Stop
                  </button>
                ) : (
                  <button
                    type="button"
                    onClick={(e) => handleSubmit(e)}
                    disabled={!input.trim()}
                    className={clsx(
                      'px-3 py-1.5 rounded-lg transition-colors flex items-center gap-1.5 text-xs font-medium',
                      input.trim()
                        ? 'bg-[var(--chat-accent)] hover:bg-[var(--chat-accent-hover)] text-white'
                        : 'bg-[var(--chat-border)] text-[var(--chat-text-secondary)] cursor-not-allowed'
                    )}
                  >
                    <Send className="w-3 h-3" />
                    Send
                  </button>
                )}
              </div>
            </div>
          </div>
        </div>
      )
    }

    // Default bottom input style
    return (
      <div className="border-t border-[var(--chat-border)] p-4">
        <form onSubmit={handleSubmit} className={clsx('flex gap-2', centered && 'max-w-3xl mx-auto')}>
          <textarea
            ref={inputRef}
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={handleKeyDown}
            placeholder={currentPlaceholder}
            disabled={isProcessing}
            rows={1}
            className={clsx(
              'flex-1 px-4 py-3 rounded-xl border border-[var(--chat-border)] bg-[var(--chat-surface)]',
              'text-sm text-[var(--chat-text)] placeholder:text-[var(--chat-text-secondary)]',
              'focus:outline-none focus:border-[var(--chat-accent)] resize-none',
              'disabled:opacity-50'
            )}
          />

          {isProcessing ? (
            <button
              type="button"
              onClick={onStop}
              className={clsx(
                'flex-shrink-0 p-3 rounded-xl bg-[var(--chat-error)] text-white',
                'hover:bg-[var(--chat-error)]/80 transition-colors'
              )}
            >
              <Square className="w-5 h-5" />
            </button>
          ) : (
            <button
              type="submit"
              disabled={!input.trim()}
              className={clsx(
                'flex-shrink-0 p-3 rounded-xl bg-[var(--chat-accent)] text-white',
                'hover:bg-[var(--chat-accent-hover)] transition-colors',
                'disabled:opacity-50 disabled:cursor-not-allowed'
              )}
            >
              <Send className="w-5 h-5" />
            </button>
          )}
        </form>
        {shouldShowHint && (
          <p className={clsx('mt-2 text-xs text-center text-[var(--chat-text-secondary)]', centered && 'max-w-3xl mx-auto')}>
            Enter to send · Shift+Enter for new line
          </p>
        )}
      </div>
    )
  }

  // Render suggestion buttons
  const renderSuggestions = () => {
    if (!suggestions?.length) return null
    return (
      <div className="flex flex-wrap justify-center gap-2 mt-4">
        {suggestions.map((suggestion) => (
          <button
            key={suggestion}
            onClick={() => onSend?.(suggestion)}
            className={clsx(
              'px-3 py-1.5 rounded-lg text-xs',
              'bg-[var(--chat-surface)] border border-[var(--chat-border)]',
              'hover:border-[var(--chat-accent)]/50 transition-colors',
              'text-[var(--chat-text)]'
            )}
          >
            {suggestion}
          </button>
        ))}
      </div>
    )
  }

  // Empty state with top-input layout
  if (messages.length === 0 && emptyStateLayout === 'top-input') {
    return (
      <div
        className={clsx(
          'flex flex-col h-full bg-[var(--chat-bg)] text-[var(--chat-text)]',
          className
        )}
        style={themeStyle}
      >
        {/* Input at top */}
        {renderInput(true)}

        {/* Welcome message and suggestions centered in remaining space */}
        <div className="flex-1 flex flex-col items-center justify-center p-4">
          {welcomeMessage}
          {renderSuggestions()}
        </div>
      </div>
    )
  }

  // Default layout (or when there are messages)
  return (
    <div
      className={clsx(
        'flex flex-col h-full bg-[var(--chat-bg)] text-[var(--chat-text)]',
        className
      )}
      style={themeStyle}
    >
      {/* Messages area */}
      <div className="flex-1 overflow-y-auto chat-scrollbar">
        {messages.length === 0 && (welcomeMessage || suggestions?.length) ? (
          <div className="flex flex-col items-center justify-center h-full p-8">
            {welcomeMessage}
            {renderSuggestions()}
          </div>
        ) : (
          <div className={clsx('py-4', centered && 'max-w-3xl mx-auto')}>
            {/* Render messages - but for the streaming message, show thinking/tasks first */}
            {messages.map((message, index) => {
              const isLastMessage = index === messages.length - 1
              const isStreamingMessage = isLastMessage && isProcessing && message.role === 'assistant'

              return (
                <div key={message.id}>
                  {/* For non-streaming messages, render normally */}
                  {!isStreamingMessage && (
                    <>
                      <MessageBubble
                        message={message}
                        assistantAvatar={assistantAvatar}
                        userAvatar={userAvatar}
                        renderToolCalls={
                          message.toolCalls?.length ? () => renderToolCalls(message.toolCalls!) : undefined
                        }
                      />
                      {renderMessageExtras?.(message, false)}
                    </>
                  )}

                  {/* For streaming message, render thinking/tasks FIRST, then message */}
                  {isStreamingMessage && (
                    <>
                      {/* Processing indicator */}
                      {!thinkingText && !message.toolCalls?.length && (
                        <div className="flex items-center gap-2 px-4 py-3 text-[var(--chat-text-secondary)]">
                          <Loader2 className="w-4 h-4 chat-animate-spin" />
                          <span className="text-sm">Thinking...</span>
                        </div>
                      )}

                      {/* Thinking box */}
                      {thinkingText && (
                        <div className="px-4 py-2">
                          <ThinkingBox
                            thinking={thinkingText}
                            isStreaming={true}
                            defaultCollapsed={false}
                          />
                        </div>
                      )}

                      {/* Tool calls */}
                      {message.toolCalls?.length ? (
                        <div className="px-4 py-2">
                          {renderToolCalls(message.toolCalls)}
                        </div>
                      ) : null}

                      {/* Tasks */}
                      {tasks && tasks.length > 0 && (
                        <div className="px-4 py-2">
                          <TodoBox tasks={tasks} />
                        </div>
                      )}

                      {/* The message content (last) */}
                      <MessageBubble
                        message={message}
                        assistantAvatar={assistantAvatar}
                        userAvatar={userAvatar}
                      />
                      {renderMessageExtras?.(message, true)}
                    </>
                  )}
                </div>
              )
            })}

            {/* Pending question (shown after all messages) */}
            {pendingQuestion && (
              <div className="px-4 py-2">
                <QuestionCard
                  question={pendingQuestion}
                  onAnswer={onAnswerQuestion}
                  disabled={isProcessing}
                />
              </div>
            )}

            {/* Pending approval (shown after all messages) */}
            {pendingApproval && (
              <div className="px-4 py-2">
                <ApprovalCard
                  request={pendingApproval}
                  onApprove={() => onAnswerApproval?.(true)}
                  onDeny={() => onAnswerApproval?.(false)}
                  disabled={isProcessing}
                />
              </div>
            )}

            {/* File diffs (shown after all messages) */}
            {diffs && diffs.length > 0 && (
              <div className="px-4 py-2 space-y-2">
                {diffs.map((diff) => (
                  <DiffView key={diff.path} change={diff} showActions={false} />
                ))}
              </div>
            )}

            <div ref={messagesEndRef} />
          </div>
        )}
      </div>

      {/* Input area */}
      {renderInput(false)}
    </div>
  )
}

export default ChatContainer
