import { useState, useCallback, useRef, useEffect } from 'react'
import type { ChatMessage, TaskItem, PendingQuestion, ApprovalRequest, FileChange, Artifact, ChatAdapter, ToolCall, ConversationStore, Conversation } from '../types'
import { generateId } from '../utils'

export interface UseChatOptions {
  /** Initial messages (ignored if conversationStore is provided) */
  initialMessages?: ChatMessage[]
  /** Chat adapter for making API calls */
  adapter?: ChatAdapter
  /**
   * Conversation store for auto-persistence. When provided:
   * - Messages are automatically saved after each change
   * - Conversations can be created, switched, and deleted
   * - Messages are loaded when switching conversations
   */
  conversationStore?: ConversationStore
  /** Auto-generate conversation title from first message (default: true) */
  autoTitle?: boolean
  /** Maximum title length for auto-generated titles (default: 50) */
  maxTitleLength?: number
  /** Called when a message is sent */
  onSend?: (message: ChatMessage) => void
  /** Called when a response is received */
  onResponse?: (message: ChatMessage) => void
  /** Called on error */
  onError?: (error: Error) => void
}

export interface UseChatReturn {
  /** Current messages (includes streaming message during processing) */
  messages: ChatMessage[]
  /** Whether currently processing */
  isProcessing: boolean
  /** Current thinking text (streaming) */
  thinkingText: string
  /** Current tasks */
  tasks: TaskItem[]
  /** Pending question from assistant */
  pendingQuestion: PendingQuestion | null
  /** Pending approval request from assistant */
  pendingApproval: ApprovalRequest | null
  /** File diffs generated by assistant */
  diffs: FileChange[]
  /** Artifacts generated by assistant */
  artifacts: Artifact[]
  /** Send a message */
  sendMessage: (content: string) => Promise<void>
  /** Stop processing */
  stopProcessing: () => void
  /** Answer a pending question */
  answerQuestion: (answer: string | string[]) => void
  /** Respond to a pending approval */
  answerApproval: (approved: boolean) => void
  /** Add a message directly */
  addMessage: (message: ChatMessage) => void
  /** Update tasks */
  setTasks: (tasks: TaskItem[]) => void
  /** Set pending question */
  setPendingQuestion: (question: PendingQuestion | null) => void
  /** Set pending approval */
  setPendingApproval: (approval: ApprovalRequest | null) => void
  /** Set diffs */
  setDiffs: (diffs: FileChange[]) => void
  /** Set artifacts */
  setArtifacts: (artifacts: Artifact[]) => void
  /** Clear messages and all state */
  clearMessages: () => void
  /** Replace all messages (for loading conversations) or update with function */
  setMessages: (messages: ChatMessage[] | ((prev: ChatMessage[]) => ChatMessage[])) => void

  // ============ Conversation Management (only available when conversationStore is provided) ============

  /** All conversations (empty array if no conversationStore) */
  conversations: Conversation[]
  /** Currently active conversation (null if no conversationStore or no active conversation) */
  currentConversation: Conversation | null
  /** Whether conversations are loading */
  isLoadingConversations: boolean
  /** Create a new conversation and switch to it */
  createConversation: (title?: string) => Promise<Conversation | null>
  /** Switch to a different conversation */
  selectConversation: (id: string) => Promise<void>
  /** Rename a conversation */
  renameConversation: (id: string, title: string) => Promise<void>
  /** Delete a conversation */
  deleteConversation: (id: string) => Promise<void>
}

export function useChat(options: UseChatOptions = {}): UseChatReturn {
  const {
    initialMessages = [],
    adapter,
    conversationStore,
    autoTitle = true,
    maxTitleLength = 50,
    onSend,
    onResponse,
    onError,
  } = options

  const [messages, setMessages] = useState<ChatMessage[]>(initialMessages)
  const [isProcessing, setIsProcessing] = useState(false)
  const [thinkingText, setThinkingText] = useState('')
  const [tasks, setTasks] = useState<TaskItem[]>([])
  const [pendingQuestion, setPendingQuestion] = useState<PendingQuestion | null>(null)
  const [pendingApproval, setPendingApproval] = useState<ApprovalRequest | null>(null)
  const [diffs, setDiffs] = useState<FileChange[]>([])
  const [artifacts, setArtifacts] = useState<Artifact[]>([])

  // Conversation management state
  const [conversations, setConversations] = useState<Conversation[]>([])
  const [currentConversationId, setCurrentConversationId] = useState<string | null>(null)
  const [isLoadingConversations, setIsLoadingConversations] = useState(!!conversationStore)

  const abortControllerRef = useRef<AbortController | null>(null)
  const streamingMessageIdRef = useRef<string | null>(null)
  const persistTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null)

  // Get current conversation object
  const currentConversation = conversations.find((c) => c.id === currentConversationId) || null

  // Load conversations on mount (if store provided)
  useEffect(() => {
    if (!conversationStore) return

    const loadConversations = async () => {
      setIsLoadingConversations(true)
      try {
        const list = await conversationStore.list()
        setConversations(list)

        // If there are conversations, select the most recent one
        if (list.length > 0) {
          const mostRecent = list[0] // list is sorted by updatedAt desc
          setCurrentConversationId(mostRecent.id)
          setMessages(mostRecent.messages)
        }
      } finally {
        setIsLoadingConversations(false)
      }
    }

    loadConversations()
  }, [conversationStore])

  // Auto-persist messages when they change (debounced)
  useEffect(() => {
    if (!conversationStore || !currentConversationId) return
    // Don't persist while streaming
    if (streamingMessageIdRef.current) return

    // Clear existing timeout
    if (persistTimeoutRef.current) {
      clearTimeout(persistTimeoutRef.current)
    }

    // Debounce persistence to avoid excessive writes
    persistTimeoutRef.current = setTimeout(async () => {
      try {
        // Auto-generate title from first user message
        let title: string | undefined
        if (autoTitle && messages.length > 0) {
          const firstUserMessage = messages.find((m) => m.role === 'user')
          if (firstUserMessage) {
            title = firstUserMessage.content.slice(0, maxTitleLength)
            if (firstUserMessage.content.length > maxTitleLength) {
              title += '...'
            }
          }
        }

        const updated = await conversationStore.update(currentConversationId, {
          messages,
          ...(title ? { title } : {}),
        })

        setConversations((prev) =>
          prev.map((c) => (c.id === currentConversationId ? updated : c))
        )
      } catch (error) {
        console.error('Failed to persist conversation:', error)
      }
    }, 300)

    return () => {
      if (persistTimeoutRef.current) {
        clearTimeout(persistTimeoutRef.current)
      }
    }
  }, [conversationStore, currentConversationId, messages, autoTitle, maxTitleLength])

  const addMessage = useCallback((message: ChatMessage) => {
    setMessages((prev) => [...prev, message])
  }, [])

  const clearMessages = useCallback(() => {
    setMessages([])
    setTasks([])
    setPendingQuestion(null)
    setPendingApproval(null)
    setDiffs([])
    setArtifacts([])
    setThinkingText('')
    streamingMessageIdRef.current = null
  }, [])

  const replaceMessages = useCallback((newMessages: ChatMessage[] | ((prev: ChatMessage[]) => ChatMessage[])) => {
    if (typeof newMessages === 'function') {
      setMessages(newMessages)
    } else {
      setMessages(newMessages)
      setTasks([])
      setPendingQuestion(null)
      setPendingApproval(null)
      setDiffs([])
      setArtifacts([])
      setThinkingText('')
      streamingMessageIdRef.current = null
    }
  }, [])

  const stopProcessing = useCallback(() => {
    abortControllerRef.current?.abort()
    setIsProcessing(false)
    // Remove streaming message if we stop mid-stream
    if (streamingMessageIdRef.current) {
      setMessages((prev) => prev.filter((m) => m.id !== streamingMessageIdRef.current))
      streamingMessageIdRef.current = null
    }
  }, [])

  // Helper to update the streaming message in-place
  const updateStreamingMessage = useCallback(
    (updater: (msg: ChatMessage) => ChatMessage) => {
      const streamingId = streamingMessageIdRef.current
      if (!streamingId) return

      setMessages((prev) =>
        prev.map((msg) => (msg.id === streamingId ? updater(msg) : msg))
      )
    },
    []
  )

  // Helper to create or get the streaming message
  const ensureStreamingMessage = useCallback(() => {
    if (streamingMessageIdRef.current) return

    const streamingMessage: ChatMessage = {
      id: generateId(),
      role: 'assistant',
      content: '',
      timestamp: new Date(),
      metadata: { isStreaming: true },
    }
    streamingMessageIdRef.current = streamingMessage.id
    setMessages((prev) => [...prev, streamingMessage])
  }, [])

  const sendMessage = useCallback(
    async (content: string) => {
      const userMessage: ChatMessage = {
        id: generateId(),
        role: 'user',
        content,
        timestamp: new Date(),
      }

      addMessage(userMessage)
      onSend?.(userMessage)

      if (!adapter) {
        // No adapter - just add the message
        return
      }

      setIsProcessing(true)
      setThinkingText('')
      streamingMessageIdRef.current = null
      abortControllerRef.current = new AbortController()

      try {
        const allMessages = [...messages, userMessage]

        const response = await adapter.sendMessage(allMessages, {
          signal: abortControllerRef.current.signal,
          onStream: (chunk) => {
            ensureStreamingMessage()
            updateStreamingMessage((msg) => ({
              ...msg,
              content: msg.content + chunk,
            }))
          },
          onThinking: (thinking) => {
            setThinkingText(thinking)
            ensureStreamingMessage()
            updateStreamingMessage((msg) => ({
              ...msg,
              thinking,
            }))
          },
          onToolCall: (toolCall) => {
            ensureStreamingMessage()
            updateStreamingMessage((msg) => {
              const existingCalls = msg.toolCalls || []
              const existingIndex = existingCalls.findIndex((tc) => tc.id === toolCall.id)

              let updatedCalls: ToolCall[]
              if (existingIndex >= 0) {
                // Update existing tool call
                updatedCalls = [...existingCalls]
                updatedCalls[existingIndex] = toolCall
              } else {
                // Add new tool call
                updatedCalls = [...existingCalls, toolCall]
              }

              return { ...msg, toolCalls: updatedCalls }
            })
          },
          onQuestion: (question) => {
            setPendingQuestion(question)
          },
          onApproval: (approval) => {
            setPendingApproval(approval)
          },
          onTask: (task) => {
            setTasks((prev) => {
              const existingIndex = prev.findIndex((t) => t.id === task.id)
              if (existingIndex >= 0) {
                const updated = [...prev]
                updated[existingIndex] = task
                return updated
              }
              return [...prev, task]
            })
          },
          onDiff: (diff) => {
            setDiffs((prev) => {
              const existingIndex = prev.findIndex((d) => d.path === diff.path)
              if (existingIndex >= 0) {
                const updated = [...prev]
                updated[existingIndex] = diff
                return updated
              }
              return [...prev, diff]
            })
          },
          onArtifact: (artifact) => {
            setArtifacts((prev) => {
              const existingIndex = prev.findIndex((a) => a.id === artifact.id)
              if (existingIndex >= 0) {
                const updated = [...prev]
                updated[existingIndex] = artifact
                return updated
              }
              return [...prev, artifact]
            })
          },
        })

        // Replace streaming message with final response
        // Capture ref value before state update - React processes updates async
        // and the ref would be null by the time the updater runs
        const streamingId = streamingMessageIdRef.current
        if (streamingId) {
          setMessages((prev) =>
            prev.map((msg) =>
              msg.id === streamingId
                ? { ...response, id: msg.id } // Keep the same ID for React key stability
                : msg
            )
          )
        } else {
          // No streaming happened, just add the response
          addMessage(response)
        }

        onResponse?.(response)
      } catch (error) {
        if ((error as Error).name !== 'AbortError') {
          onError?.(error as Error)
          // Remove streaming message on error
          // Capture ref value before state update
          const streamingId = streamingMessageIdRef.current
          if (streamingId) {
            setMessages((prev) => prev.filter((m) => m.id !== streamingId))
          }
        }
      } finally {
        setIsProcessing(false)
        setThinkingText('')
        streamingMessageIdRef.current = null
        abortControllerRef.current = null
      }
    },
    [adapter, messages, addMessage, onSend, onResponse, onError, ensureStreamingMessage, updateStreamingMessage]
  )

  const answerQuestion = useCallback(
    (answer: string | string[]) => {
      if (!pendingQuestion) return

      const answerText = Array.isArray(answer) ? answer.join(', ') : answer
      setPendingQuestion(null)

      // Just send the message - sendMessage will add the user message
      sendMessage(answerText)
    },
    [pendingQuestion, sendMessage]
  )

  const answerApproval = useCallback(
    (approved: boolean) => {
      if (!pendingApproval) return

      setPendingApproval(null)

      // Just send the message - sendMessage will add the user message
      sendMessage(approved ? 'Approved' : 'Denied')
    },
    [pendingApproval, sendMessage]
  )

  // ============ Conversation Management Methods ============

  const createConversation = useCallback(
    async (title?: string): Promise<Conversation | null> => {
      if (!conversationStore) return null

      const conversation = await conversationStore.create(title)
      setConversations((prev) => [conversation, ...prev])
      setCurrentConversationId(conversation.id)
      // Clear messages for new conversation
      setMessages([])
      setTasks([])
      setPendingQuestion(null)
      setPendingApproval(null)
      setDiffs([])
      setArtifacts([])
      setThinkingText('')
      streamingMessageIdRef.current = null
      return conversation
    },
    [conversationStore]
  )

  const selectConversation = useCallback(
    async (id: string): Promise<void> => {
      if (!conversationStore) return

      const conversation = await conversationStore.get(id)
      if (conversation) {
        setCurrentConversationId(id)
        setMessages(conversation.messages)
        // Reset transient state
        setTasks([])
        setPendingQuestion(null)
        setPendingApproval(null)
        setDiffs([])
        setArtifacts([])
        setThinkingText('')
        streamingMessageIdRef.current = null
      }
    },
    [conversationStore]
  )

  const renameConversation = useCallback(
    async (id: string, title: string): Promise<void> => {
      if (!conversationStore) return

      const updated = await conversationStore.update(id, { title })
      setConversations((prev) => prev.map((c) => (c.id === id ? updated : c)))
    },
    [conversationStore]
  )

  const deleteConversation = useCallback(
    async (id: string): Promise<void> => {
      if (!conversationStore) return

      await conversationStore.delete(id)
      setConversations((prev) => prev.filter((c) => c.id !== id))

      // If deleting current conversation, switch to another or clear
      if (currentConversationId === id) {
        const remaining = conversations.filter((c) => c.id !== id)
        if (remaining.length > 0) {
          await selectConversation(remaining[0].id)
        } else {
          setCurrentConversationId(null)
          setMessages([])
        }
      }
    },
    [conversationStore, currentConversationId, conversations, selectConversation]
  )

  return {
    messages,
    isProcessing,
    thinkingText,
    tasks,
    pendingQuestion,
    pendingApproval,
    diffs,
    artifacts,
    sendMessage,
    stopProcessing,
    answerQuestion,
    answerApproval,
    addMessage,
    setTasks,
    setPendingQuestion,
    setPendingApproval,
    setDiffs,
    setArtifacts,
    clearMessages,
    setMessages: replaceMessages,

    // Conversation management
    conversations,
    currentConversation,
    isLoadingConversations,
    createConversation,
    selectConversation,
    renameConversation,
    deleteConversation,
  }
}
