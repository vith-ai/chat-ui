import { useState, useCallback, useRef, useEffect } from 'react'
import type { ChatMessage, TaskItem, PendingQuestion, ApprovalRequest, FileChange, Artifact, ChatAdapter, ToolCall, ConversationStore, Conversation, ToolRegistry, PermissionConfig, ToolResult, ToolExecutor } from '../types'
import { generateId } from '../utils'
import { getEffectivePermission } from '../permissions'

export interface UseChatOptions {
  /** Initial messages (ignored if conversationStore is provided) */
  initialMessages?: ChatMessage[]
  /** Chat adapter for making API calls */
  adapter?: ChatAdapter
  /**
   * Conversation store for auto-persistence. When provided:
   * - Messages are automatically saved after each change
   * - Conversations can be created, switched, and deleted
   * - Messages are loaded when switching conversations
   */
  conversationStore?: ConversationStore
  /** Auto-generate conversation title from first message (default: true) */
  autoTitle?: boolean
  /** Maximum title length for auto-generated titles (default: 50) */
  maxTitleLength?: number
  /**
   * Tool executor function - called to execute tools.
   * When provided with toolRegistry/permissionConfig, permissions are checked before execution.
   */
  toolExecutor?: ToolExecutor
  /**
   * Tool registry for permission checking.
   * Works with permissionConfig to control tool approval flow.
   */
  toolRegistry?: ToolRegistry
  /**
   * Permission configuration for tool approval.
   * Controls which tools require confirmation, notification, or are auto-approved.
   */
  permissionConfig?: PermissionConfig
  /** Called when a message is sent */
  onSend?: (message: ChatMessage) => void
  /** Called when a response is received */
  onResponse?: (message: ChatMessage) => void
  /** Called on error */
  onError?: (error: Error) => void
}

export interface UseChatReturn {
  /** Current messages (includes streaming message during processing) */
  messages: ChatMessage[]
  /** Whether currently processing */
  isProcessing: boolean
  /** Current thinking text (streaming) */
  thinkingText: string
  /** Current tasks */
  tasks: TaskItem[]
  /** Pending question from assistant */
  pendingQuestion: PendingQuestion | null
  /** Pending approval request from assistant */
  pendingApproval: ApprovalRequest | null
  /** File diffs generated by assistant */
  diffs: FileChange[]
  /** Artifacts generated by assistant */
  artifacts: Artifact[]
  /** Current error (null if none) */
  error: Error | null
  /** Adapter feature flags (null if no adapter) */
  adapterFeatures: { streaming: boolean; thinking: boolean; toolUse: boolean } | null
  /** Send a message */
  sendMessage: (content: string) => Promise<void>
  /** Stop processing */
  stopProcessing: () => void
  /** Answer a pending question */
  answerQuestion: (answer: string | string[]) => void
  /** Respond to a pending approval */
  answerApproval: (approved: boolean) => void
  /** Retry the last user message */
  retry: () => Promise<void>
  /** Regenerate the last assistant response (removes it and re-sends) */
  regenerate: () => Promise<void>
  /** Add a message directly */
  addMessage: (message: ChatMessage) => void
  /** Update tasks */
  setTasks: (tasks: TaskItem[]) => void
  /** Set pending question */
  setPendingQuestion: (question: PendingQuestion | null) => void
  /** Set pending approval */
  setPendingApproval: (approval: ApprovalRequest | null) => void
  /** Set diffs */
  setDiffs: (diffs: FileChange[]) => void
  /** Set artifacts */
  setArtifacts: (artifacts: Artifact[]) => void
  /** Clear the current error */
  clearError: () => void
  /** Clear messages and all state */
  clearMessages: () => void
  /** Replace all messages (for loading conversations) or update with function */
  setMessages: (messages: ChatMessage[] | ((prev: ChatMessage[]) => ChatMessage[])) => void

  // ============ Conversation Management (only available when conversationStore is provided) ============

  /** All conversations (empty array if no conversationStore) */
  conversations: Conversation[]
  /** Currently active conversation (null if no conversationStore or no active conversation) */
  currentConversation: Conversation | null
  /** Whether conversations are loading */
  isLoadingConversations: boolean
  /** Create a new conversation and switch to it */
  createConversation: (title?: string) => Promise<Conversation | null>
  /** Switch to a different conversation */
  selectConversation: (id: string) => Promise<void>
  /** Rename a conversation */
  renameConversation: (id: string, title: string) => Promise<void>
  /** Delete a conversation */
  deleteConversation: (id: string) => Promise<void>
}

export function useChat(options: UseChatOptions = {}): UseChatReturn {
  const {
    initialMessages = [],
    adapter,
    conversationStore,
    autoTitle = true,
    maxTitleLength = 50,
    toolExecutor: userToolExecutor,
    toolRegistry,
    permissionConfig,
    onSend,
    onResponse,
    onError,
  } = options

  const [messages, setMessages] = useState<ChatMessage[]>(initialMessages)
  const [isProcessing, setIsProcessing] = useState(false)
  const [thinkingText, setThinkingText] = useState('')
  const [tasks, setTasks] = useState<TaskItem[]>([])
  const [pendingQuestion, setPendingQuestion] = useState<PendingQuestion | null>(null)
  const [pendingApproval, setPendingApproval] = useState<ApprovalRequest | null>(null)
  const [diffs, setDiffs] = useState<FileChange[]>([])
  const [artifacts, setArtifacts] = useState<Artifact[]>([])
  const [error, setError] = useState<Error | null>(null)

  // Conversation management state
  const [conversations, setConversations] = useState<Conversation[]>([])
  const [currentConversationId, setCurrentConversationId] = useState<string | null>(null)
  const [isLoadingConversations, setIsLoadingConversations] = useState(!!conversationStore)

  const abortControllerRef = useRef<AbortController | null>(null)
  const streamingMessageIdRef = useRef<string | null>(null)
  const persistTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null)
  // Track pending tool approval - resolves when user approves/denies
  const pendingToolApprovalRef = useRef<{
    toolCall: ToolCall
    resolve: (approved: boolean) => void
  } | null>(null)

  // Get current conversation object
  const currentConversation = conversations.find((c) => c.id === currentConversationId) || null

  // Load conversations on mount (if store provided)
  useEffect(() => {
    if (!conversationStore) return

    const loadConversations = async () => {
      setIsLoadingConversations(true)
      try {
        const list = await conversationStore.list()
        setConversations(list)

        // If there are conversations, select the most recent one
        if (list.length > 0) {
          const mostRecent = list[0] // list is sorted by updatedAt desc
          setCurrentConversationId(mostRecent.id)
          setMessages(mostRecent.messages)
        }
      } finally {
        setIsLoadingConversations(false)
      }
    }

    loadConversations()
  }, [conversationStore])

  // Auto-persist messages when they change (debounced)
  useEffect(() => {
    if (!conversationStore || !currentConversationId) return
    // Don't persist while streaming
    if (streamingMessageIdRef.current) return

    // Clear existing timeout
    if (persistTimeoutRef.current) {
      clearTimeout(persistTimeoutRef.current)
    }

    // Debounce persistence to avoid excessive writes
    persistTimeoutRef.current = setTimeout(async () => {
      try {
        // Auto-generate title from first user message
        let title: string | undefined
        if (autoTitle && messages.length > 0) {
          const firstUserMessage = messages.find((m) => m.role === 'user')
          if (firstUserMessage) {
            title = firstUserMessage.content.slice(0, maxTitleLength)
            if (firstUserMessage.content.length > maxTitleLength) {
              title += '...'
            }
          }
        }

        const updated = await conversationStore.update(currentConversationId, {
          messages,
          ...(title ? { title } : {}),
        })

        setConversations((prev) =>
          prev.map((c) => (c.id === currentConversationId ? updated : c))
        )
      } catch (error) {
        console.error('Failed to persist conversation:', error)
      }
    }, 300)

    return () => {
      if (persistTimeoutRef.current) {
        clearTimeout(persistTimeoutRef.current)
      }
    }
  }, [conversationStore, currentConversationId, messages, autoTitle, maxTitleLength])

  const addMessage = useCallback((message: ChatMessage) => {
    setMessages((prev) => [...prev, message])
  }, [])

  const clearError = useCallback(() => {
    setError(null)
  }, [])

  const clearMessages = useCallback(() => {
    setMessages([])
    setTasks([])
    setPendingQuestion(null)
    setPendingApproval(null)
    setDiffs([])
    setArtifacts([])
    setError(null)
    setThinkingText('')
    streamingMessageIdRef.current = null
  }, [])

  const replaceMessages = useCallback((newMessages: ChatMessage[] | ((prev: ChatMessage[]) => ChatMessage[])) => {
    if (typeof newMessages === 'function') {
      setMessages(newMessages)
    } else {
      setMessages(newMessages)
      setTasks([])
      setPendingQuestion(null)
      setPendingApproval(null)
      setDiffs([])
      setArtifacts([])
      setThinkingText('')
      streamingMessageIdRef.current = null
    }
  }, [])

  const stopProcessing = useCallback(() => {
    abortControllerRef.current?.abort()
    setIsProcessing(false)
    // Remove streaming message if we stop mid-stream
    if (streamingMessageIdRef.current) {
      setMessages((prev) => prev.filter((m) => m.id !== streamingMessageIdRef.current))
      streamingMessageIdRef.current = null
    }
  }, [])

  // Helper to update the streaming message in-place
  const updateStreamingMessage = useCallback(
    (updater: (msg: ChatMessage) => ChatMessage) => {
      const streamingId = streamingMessageIdRef.current
      if (!streamingId) return

      setMessages((prev) =>
        prev.map((msg) => (msg.id === streamingId ? updater(msg) : msg))
      )
    },
    []
  )

  // Helper to create or get the streaming message
  const ensureStreamingMessage = useCallback(() => {
    if (streamingMessageIdRef.current) return

    const streamingMessage: ChatMessage = {
      id: generateId(),
      role: 'assistant',
      content: '',
      timestamp: new Date(),
      metadata: { isStreaming: true },
    }
    streamingMessageIdRef.current = streamingMessage.id
    setMessages((prev) => [...prev, streamingMessage])
  }, [])

  // Permission-aware tool executor that wraps user's toolExecutor
  const permissionAwareToolExecutor: ToolExecutor | undefined = userToolExecutor
    ? async (toolCall: ToolCall): Promise<ToolResult> => {
        // Get effective permission for this tool
        const defaultConfig: PermissionConfig = { defaultPermission: 'confirm' }
        const config = permissionConfig || defaultConfig
        const toolDef = toolRegistry?.tools.find((t) => t.name === toolCall.name)
        const permission = getEffectivePermission(toolCall.name, toolDef, config)

        // Handle based on permission level
        if (permission === 'deny') {
          return {
            toolCallId: toolCall.id,
            result: `Tool "${toolCall.name}" is not allowed`,
            isError: true,
          }
        }

        if (permission === 'confirm') {
          // Show approval UI and wait for user response
          const approved = await new Promise<boolean>((resolve) => {
            pendingToolApprovalRef.current = { toolCall, resolve }
            setPendingApproval({
              id: toolCall.id,
              action: toolCall.name,
              risk: toolDef?.risk || 'medium',
              details: JSON.stringify(toolCall.input, null, 2),
            })
          })

          if (!approved) {
            return {
              toolCallId: toolCall.id,
              result: `User denied execution of "${toolCall.name}"`,
              isError: true,
            }
          }
        }

        // 'auto' or 'notify' or approved 'confirm' - execute the tool
        return userToolExecutor(toolCall)
      }
    : undefined

  const sendMessage = useCallback(
    async (content: string) => {
      const userMessage: ChatMessage = {
        id: generateId(),
        role: 'user',
        content,
        timestamp: new Date(),
      }

      addMessage(userMessage)
      onSend?.(userMessage)

      if (!adapter) {
        // No adapter - just add the message
        return
      }

      setIsProcessing(true)
      setThinkingText('')
      setError(null) // Clear previous error
      streamingMessageIdRef.current = null
      abortControllerRef.current = new AbortController()

      try {
        const allMessages = [...messages, userMessage]

        const response = await adapter.sendMessage(allMessages, {
          signal: abortControllerRef.current.signal,
          toolExecutor: permissionAwareToolExecutor,
          onStream: (chunk) => {
            ensureStreamingMessage()
            updateStreamingMessage((msg) => ({
              ...msg,
              content: msg.content + chunk,
            }))
          },
          onThinking: (thinking) => {
            setThinkingText(thinking)
            ensureStreamingMessage()
            updateStreamingMessage((msg) => ({
              ...msg,
              thinking,
            }))
          },
          onToolCall: (toolCall) => {
            ensureStreamingMessage()
            updateStreamingMessage((msg) => {
              const existingCalls = msg.toolCalls || []
              const existingIndex = existingCalls.findIndex((tc) => tc.id === toolCall.id)

              let updatedCalls: ToolCall[]
              if (existingIndex >= 0) {
                // Update existing tool call
                updatedCalls = [...existingCalls]
                updatedCalls[existingIndex] = toolCall
              } else {
                // Add new tool call
                updatedCalls = [...existingCalls, toolCall]
              }

              return { ...msg, toolCalls: updatedCalls }
            })
          },
          onQuestion: (question) => {
            setPendingQuestion(question)
          },
          onApproval: (approval) => {
            setPendingApproval(approval)
          },
          onTask: (task) => {
            setTasks((prev) => {
              const existingIndex = prev.findIndex((t) => t.id === task.id)
              if (existingIndex >= 0) {
                const updated = [...prev]
                updated[existingIndex] = task
                return updated
              }
              return [...prev, task]
            })
          },
          onDiff: (diff) => {
            setDiffs((prev) => {
              const existingIndex = prev.findIndex((d) => d.path === diff.path)
              if (existingIndex >= 0) {
                const updated = [...prev]
                updated[existingIndex] = diff
                return updated
              }
              return [...prev, diff]
            })
          },
          onArtifact: (artifact) => {
            setArtifacts((prev) => {
              const existingIndex = prev.findIndex((a) => a.id === artifact.id)
              if (existingIndex >= 0) {
                const updated = [...prev]
                updated[existingIndex] = artifact
                return updated
              }
              return [...prev, artifact]
            })
          },
        })

        // Replace streaming message with final response
        // Capture ref value before state update - React processes updates async
        // and the ref would be null by the time the updater runs
        const streamingId = streamingMessageIdRef.current
        if (streamingId) {
          setMessages((prev) =>
            prev.map((msg) =>
              msg.id === streamingId
                ? { ...response, id: msg.id } // Keep the same ID for React key stability
                : msg
            )
          )
        } else {
          // No streaming happened, just add the response
          addMessage(response)
        }

        onResponse?.(response)
      } catch (error) {
        if ((error as Error).name !== 'AbortError') {
          const err = error as Error
          setError(err)
          onError?.(err)
          // Remove streaming message on error
          // Capture ref value before state update
          const streamingId = streamingMessageIdRef.current
          if (streamingId) {
            setMessages((prev) => prev.filter((m) => m.id !== streamingId))
          }
        }
      } finally {
        setIsProcessing(false)
        setThinkingText('')
        streamingMessageIdRef.current = null
        abortControllerRef.current = null
      }
    },
    [adapter, messages, addMessage, onSend, onResponse, onError, ensureStreamingMessage, updateStreamingMessage]
  )

  const answerQuestion = useCallback(
    (answer: string | string[]) => {
      if (!pendingQuestion) return

      const answerText = Array.isArray(answer) ? answer.join(', ') : answer
      setPendingQuestion(null)

      // Just send the message - sendMessage will add the user message
      sendMessage(answerText)
    },
    [pendingQuestion, sendMessage]
  )

  const answerApproval = useCallback(
    (approved: boolean) => {
      if (!pendingApproval) return

      setPendingApproval(null)

      // If this is a tool permission approval, resolve the waiting promise
      if (pendingToolApprovalRef.current) {
        pendingToolApprovalRef.current.resolve(approved)
        pendingToolApprovalRef.current = null
        return
      }

      // For other approvals, send a message
      sendMessage(approved ? 'Approved' : 'Denied')
    },
    [pendingApproval, sendMessage]
  )

  const retry = useCallback(async () => {
    // Find the last user message
    const lastUserMessage = [...messages].reverse().find((m) => m.role === 'user')
    if (!lastUserMessage) return

    // Re-send the same content
    await sendMessage(lastUserMessage.content)
  }, [messages, sendMessage])

  const regenerate = useCallback(async () => {
    // Find the last user message and remove all messages after it
    let lastUserIndex = -1
    for (let i = messages.length - 1; i >= 0; i--) {
      if (messages[i].role === 'user') {
        lastUserIndex = i
        break
      }
    }
    if (lastUserIndex === -1) return

    // Remove messages after the last user message (the assistant responses)
    setMessages(messages.slice(0, lastUserIndex + 1))

    // Clear transient state
    setTasks([])
    setPendingQuestion(null)
    setPendingApproval(null)
    setDiffs([])
    setArtifacts([])
    setError(null)

    // Re-send to get a new response
    // Note: We need to manually trigger the adapter since the message is already in the list
    if (!adapter) return

    setIsProcessing(true)
    setThinkingText('')
    streamingMessageIdRef.current = null
    abortControllerRef.current = new AbortController()

    try {
      const allMessages = messages.slice(0, lastUserIndex + 1)

      const response = await adapter.sendMessage(allMessages, {
        signal: abortControllerRef.current.signal,
        toolExecutor: permissionAwareToolExecutor,
        onStream: (chunk) => {
          ensureStreamingMessage()
          updateStreamingMessage((msg) => ({
            ...msg,
            content: msg.content + chunk,
          }))
        },
        onThinking: (thinking) => {
          setThinkingText(thinking)
          ensureStreamingMessage()
          updateStreamingMessage((msg) => ({
            ...msg,
            thinking,
          }))
        },
        onToolCall: (toolCall) => {
          ensureStreamingMessage()
          updateStreamingMessage((msg) => {
            const existingCalls = msg.toolCalls || []
            const existingIndex = existingCalls.findIndex((tc) => tc.id === toolCall.id)

            let updatedCalls: ToolCall[]
            if (existingIndex >= 0) {
              updatedCalls = [...existingCalls]
              updatedCalls[existingIndex] = toolCall
            } else {
              updatedCalls = [...existingCalls, toolCall]
            }

            return { ...msg, toolCalls: updatedCalls }
          })
        },
        onQuestion: (question) => {
          setPendingQuestion(question)
        },
        onApproval: (approval) => {
          setPendingApproval(approval)
        },
        onTask: (task) => {
          setTasks((prev) => {
            const existingIndex = prev.findIndex((t) => t.id === task.id)
            if (existingIndex >= 0) {
              const updated = [...prev]
              updated[existingIndex] = task
              return updated
            }
            return [...prev, task]
          })
        },
        onDiff: (diff) => {
          setDiffs((prev) => {
            const existingIndex = prev.findIndex((d) => d.path === diff.path)
            if (existingIndex >= 0) {
              const updated = [...prev]
              updated[existingIndex] = diff
              return updated
            }
            return [...prev, diff]
          })
        },
        onArtifact: (artifact) => {
          setArtifacts((prev) => {
            const existingIndex = prev.findIndex((a) => a.id === artifact.id)
            if (existingIndex >= 0) {
              const updated = [...prev]
              updated[existingIndex] = artifact
              return updated
            }
            return [...prev, artifact]
          })
        },
      })

      const streamingId = streamingMessageIdRef.current
      if (streamingId) {
        setMessages((prev) =>
          prev.map((msg) =>
            msg.id === streamingId ? { ...response, id: msg.id } : msg
          )
        )
      } else {
        addMessage(response)
      }

      onResponse?.(response)
    } catch (error) {
      if ((error as Error).name !== 'AbortError') {
        const err = error as Error
        setError(err)
        onError?.(err)
        const streamingId = streamingMessageIdRef.current
        if (streamingId) {
          setMessages((prev) => prev.filter((m) => m.id !== streamingId))
        }
      }
    } finally {
      setIsProcessing(false)
      setThinkingText('')
      streamingMessageIdRef.current = null
      abortControllerRef.current = null
    }
  }, [messages, adapter, onResponse, onError, ensureStreamingMessage, updateStreamingMessage, addMessage])

  // ============ Conversation Management Methods ============

  const createConversation = useCallback(
    async (title?: string): Promise<Conversation | null> => {
      if (!conversationStore) return null

      const conversation = await conversationStore.create(title)
      setConversations((prev) => [conversation, ...prev])
      setCurrentConversationId(conversation.id)
      // Clear messages for new conversation
      setMessages([])
      setTasks([])
      setPendingQuestion(null)
      setPendingApproval(null)
      setDiffs([])
      setArtifacts([])
      setThinkingText('')
      streamingMessageIdRef.current = null
      return conversation
    },
    [conversationStore]
  )

  const selectConversation = useCallback(
    async (id: string): Promise<void> => {
      if (!conversationStore) return

      const conversation = await conversationStore.get(id)
      if (conversation) {
        setCurrentConversationId(id)
        setMessages(conversation.messages)
        // Reset transient state
        setTasks([])
        setPendingQuestion(null)
        setPendingApproval(null)
        setDiffs([])
        setArtifacts([])
        setThinkingText('')
        streamingMessageIdRef.current = null
      }
    },
    [conversationStore]
  )

  const renameConversation = useCallback(
    async (id: string, title: string): Promise<void> => {
      if (!conversationStore) return

      const updated = await conversationStore.update(id, { title })
      setConversations((prev) => prev.map((c) => (c.id === id ? updated : c)))
    },
    [conversationStore]
  )

  const deleteConversation = useCallback(
    async (id: string): Promise<void> => {
      if (!conversationStore) return

      await conversationStore.delete(id)
      setConversations((prev) => prev.filter((c) => c.id !== id))

      // If deleting current conversation, switch to another or clear
      if (currentConversationId === id) {
        const remaining = conversations.filter((c) => c.id !== id)
        if (remaining.length > 0) {
          await selectConversation(remaining[0].id)
        } else {
          setCurrentConversationId(null)
          setMessages([])
        }
      }
    },
    [conversationStore, currentConversationId, conversations, selectConversation]
  )

  return {
    messages,
    isProcessing,
    thinkingText,
    tasks,
    pendingQuestion,
    pendingApproval,
    diffs,
    artifacts,
    error,
    adapterFeatures: adapter?.features || null,
    sendMessage,
    stopProcessing,
    answerQuestion,
    answerApproval,
    retry,
    regenerate,
    addMessage,
    setTasks,
    setPendingQuestion,
    setPendingApproval,
    setDiffs,
    setArtifacts,
    clearError,
    clearMessages,
    setMessages: replaceMessages,

    // Conversation management
    conversations,
    currentConversation,
    isLoadingConversations,
    createConversation,
    selectConversation,
    renameConversation,
    deleteConversation,
  }
}
